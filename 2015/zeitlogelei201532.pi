/* Zeit Logelei 2015/32 */
import util, cp.
main => 
   M = {{_,  _,  2,_,  _,_,  _,  _,  _,_},
		{1,  _,  _,4,  _,_,  _,  _,  _,_},
		{_,  _,  _,5,  _,_,  _,  _,  _,_},
		{3,  _,  _,6,  _,_,  _,  _,  _,_},
		{_,_  ,104,_,  _,_,  _,103,  _,_},
		{_,102,  _,_,  _,_,  6,101,  8,_},
		{_,201,105,_,203,_,  _,    _,202,9}},
   MVars = array_matrix_to_list(M),
   Vals = [1,101,201,2,102,202,3,103,203,4,104,5,105,6,8,9,11],
   MVars :: Vals,
   foreach(Val in Vals)
   		count(Val, MVars, #=, Val mod 100)
   end,
   foreach( (R,C) in [(1,1), (1,2), (2,2), (2,3), (3,3), (4,2), (4,3), (5,1), (5,2), (6,1), (7,1)])
   		M[R,C] #= 11
   end,
   foreach( (R,C) in [(1,8), (1,9), (1,10), (2,10), (3,10), (4,10), (5,10), (6,10), (7,10)])
   		M[R,C] #= 9
   end,
   M[6,4] #= 5,  M[3,6] #= 5, % M[3,7] #= 5,
   % Jeder hat einen Nachbarn:
   foreach(R in 1..7, C in 1..10)
   	( 
   	M[R,C] mod 100 #= 1
   	;
	0 #< sum([(M[R,C]#=M[R,C1]) : C1 in [C-1,C+1], C1>0, C1=<10])
	   + sum([(M[R,C]#=M[R1,C]) : R1 in [R-1,R+1], R1>0, R1=<7])
   	)
   end,
   solve([down], MVars),
   foreach(R in 1..7) 
      foreach(C in 1..10) 
            printf("%2d ", M[R,C] mod 100 )
	  end, nl
   end.
/*
11 11  2  2 4 4 8 9 9 9;	1101 1102  201  202  403  404  801  901  902  903
 1 11 11  4 4 5 8 8 8 9;	 101 1103 1104  401  402  504  802  803  804  904
 3  3 11  5 5 5 5 3 8 9;     301  302 1105  501  502  503  505  301  805  905
 3 11 11  6 6 6 6 3 8 9;	 303 1107 1106  601  602  603  604  302  806  906
11 11  4  4 4 4 6 3 8 9;    1109 1108  401  402  403  404  605  303  807  907
11  2  2  5 5 5 6 1 8 9;	1110  201  202  503  504  505  606  101  808  908
11  1  5  5 3 3 3 2 2 9		1111  101  501  502  301  302  303  201  202  909
CPU time 0.004 seconds korrekt */